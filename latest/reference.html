<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Knet.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Knet.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="install.html">Setting up Knet</a></li><li><a class="toctext" href="tutorial.html">Introduction to Knet</a></li><li class="current"><a class="toctext" href="reference.html">Reference</a><ul class="internal"><li><a class="toctext" href="#AutoGrad-1">AutoGrad</a></li><li><a class="toctext" href="#KnetArray-1">KnetArray</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li><li><a class="toctext" href="#Convolution-and-Pooling-1">Convolution and Pooling</a></li><li><a class="toctext" href="#Recurrent-neural-networks-1">Recurrent neural networks</a></li><li><a class="toctext" href="#Batch-Normalization-1">Batch Normalization</a></li><li><a class="toctext" href="#Optimization-methods-1">Optimization methods</a></li><li><a class="toctext" href="#Hyperparameter-optimization-1">Hyperparameter optimization</a></li><li><a class="toctext" href="#Initialization-1">Initialization</a></li><li><a class="toctext" href="#AutoGrad-(advanced)-1">AutoGrad (advanced)</a></li><li><a class="toctext" href="#Function-Index-1">Function Index</a></li></ul></li></ul></li><li><span class="toctext">Textbook</span><ul><li><a class="toctext" href="backprop.html">Backpropagation</a></li><li><a class="toctext" href="softmax.html">Softmax Classification</a></li><li><a class="toctext" href="mlp.html">Multilayer Perceptrons</a></li><li><a class="toctext" href="cnn.html">Convolutional Neural Networks</a></li><li><a class="toctext" href="rnn.html">Recurrent Neural Networks</a></li><li><a class="toctext" href="rl.html">Reinforcement Learning</a></li><li><a class="toctext" href="opt.html">Optimization</a></li><li><a class="toctext" href="gen.html">Generalization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="reference.html">Reference</a></li></ul><a class="edit-page" href="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><p><strong>Contents</strong></p><ul><li><a href="reference.html#Reference-1">Reference</a></li><ul><li><a href="reference.html#AutoGrad-1">AutoGrad</a></li><li><a href="reference.html#KnetArray-1">KnetArray</a></li><li><a href="reference.html#Utilities-1">Utilities</a></li><li><a href="reference.html#Convolution-and-Pooling-1">Convolution and Pooling</a></li><li><a href="reference.html#Recurrent-neural-networks-1">Recurrent neural networks</a></li><li><a href="reference.html#Batch-Normalization-1">Batch Normalization</a></li><li><a href="reference.html#Optimization-methods-1">Optimization methods</a></li><li><a href="reference.html#Hyperparameter-optimization-1">Hyperparameter optimization</a></li><li><a href="reference.html#Initialization-1">Initialization</a></li><li><a href="reference.html#AutoGrad-(advanced)-1">AutoGrad (advanced)</a></li><li><a href="reference.html#Function-Index-1">Function Index</a></li></ul></ul><h2><a class="nav-anchor" id="AutoGrad-1" href="#AutoGrad-1">AutoGrad</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.grad" href="#AutoGrad.grad"><code>AutoGrad.grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Usage:</p><pre><code class="language-none">x = Param([1,2,3])          # user declares parameters
x =&gt; P([1,2,3])             # they are wrapped in a struct
value(x) =&gt; [1,2,3]         # we can get the original value
sum(abs2,x) =&gt; 14           # they act like regular values outside of differentiation
y = @diff sum(abs2,x)       # if you want the gradients
y =&gt; T(14)                  # you get another struct
value(y) =&gt; 14              # which represents the same value
grad(y,x) =&gt; [2,4,6]        # but also contains gradients for all Params</code></pre><p><code>Param(x)</code> returns a struct that acts like <code>x</code> but marks it as a parameter you want to compute gradients with respect to.</p><p><code>@diff expr</code> evaluates an expression and returns a struct that contains its value (which should be a scalar) and gradient information.</p><p><code>grad(y, x)</code> returns the gradient of <code>y</code> (output by @diff) with respect to any parameter <code>x::Param</code>, or  <code>nothing</code> if the gradient is 0.</p><p><code>value(x)</code> returns the value associated with <code>x</code> if <code>x</code> is a <code>Param</code> or the output of <code>@diff</code>, otherwise returns <code>x</code>.</p><p><code>params(x)</code> returns an array of Params found by a recursive search of object <code>x</code>.</p><p>Alternative usage:</p><pre><code class="language-none">x = [1 2 3]
f(x) = sum(abs2, x)
f(x) =&gt; 14
grad(f)(x) =&gt; [2 4 6]
gradloss(f)(x) =&gt; ([2 4 6], 14)</code></pre><p>Given a scalar valued function <code>f</code>, <code>grad(f,argnum=1)</code> returns another function <code>g</code> which takes the same inputs as <code>f</code> and returns the gradient of the output with respect to the argnum&#39;th argument. <code>gradloss</code> is similar except the resulting function also returns f&#39;s output.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.gradloss" href="#AutoGrad.gradloss"><code>AutoGrad.gradloss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Usage:</p><pre><code class="language-none">x = Param([1,2,3])          # user declares parameters
x =&gt; P([1,2,3])             # they are wrapped in a struct
value(x) =&gt; [1,2,3]         # we can get the original value
sum(abs2,x) =&gt; 14           # they act like regular values outside of differentiation
y = @diff sum(abs2,x)       # if you want the gradients
y =&gt; T(14)                  # you get another struct
value(y) =&gt; 14              # which represents the same value
grad(y,x) =&gt; [2,4,6]        # but also contains gradients for all Params</code></pre><p><code>Param(x)</code> returns a struct that acts like <code>x</code> but marks it as a parameter you want to compute gradients with respect to.</p><p><code>@diff expr</code> evaluates an expression and returns a struct that contains its value (which should be a scalar) and gradient information.</p><p><code>grad(y, x)</code> returns the gradient of <code>y</code> (output by @diff) with respect to any parameter <code>x::Param</code>, or  <code>nothing</code> if the gradient is 0.</p><p><code>value(x)</code> returns the value associated with <code>x</code> if <code>x</code> is a <code>Param</code> or the output of <code>@diff</code>, otherwise returns <code>x</code>.</p><p><code>params(x)</code> returns an array of Params found by a recursive search of object <code>x</code>.</p><p>Alternative usage:</p><pre><code class="language-none">x = [1 2 3]
f(x) = sum(abs2, x)
f(x) =&gt; 14
grad(f)(x) =&gt; [2 4 6]
gradloss(f)(x) =&gt; ([2 4 6], 14)</code></pre><p>Given a scalar valued function <code>f</code>, <code>grad(f,argnum=1)</code> returns another function <code>g</code> which takes the same inputs as <code>f</code> and returns the gradient of the output with respect to the argnum&#39;th argument. <code>gradloss</code> is similar except the resulting function also returns f&#39;s output.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.gradcheck" href="#AutoGrad.gradcheck"><code>AutoGrad.gradcheck</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gradcheck(f, x...; kwargs...)</code></pre><p>Numerically check the gradient of <code>f(x...)</code> and return a boolean result.</p><p>Each argument can be a Number, Array, Tuple or Dict which in turn can contain other Arrays etc.  Only 10 random entries in each large numeric array are checked by default.  If the output of <code>f</code> is not a number, we check the gradient of <code>sum(f(x...))</code>.</p><p><strong>Keywords</strong></p><ul><li><p><code>args=:</code>: the argument indices to check gradients with respect to. Could be an array or range of indices or a single index. By default all arguments that have a <code>length</code> method are checked.</p></li><li><p><code>kw=()</code>: keyword arguments to be passed to <code>f</code>.</p></li><li><p><code>nsample=10</code>: number of random entries from each numeric array in gradient <code>dw=(grad(f))(w,x...;o...)</code> compared to their numerical estimates.</p></li><li><p><code>atol=rtol=0.01</code>: tolerance parameters.  See <code>isapprox</code> for their meaning.</p></li><li><p><code>delta=0.0001</code>: step size for numerical gradient calculation.</p></li><li><p><code>verbose=1</code>: 0 prints nothing, 1 shows failing tests, 2 shows all tests.</p></li></ul></div></div></section><h2><a class="nav-anchor" id="KnetArray-1" href="#KnetArray-1">KnetArray</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.KnetArray" href="#Knet.KnetArray"><code>Knet.KnetArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">KnetArray{T}(undef,dims)
KnetArray(a::AbstractArray)
Array(k::KnetArray)</code></pre><p>Container for GPU arrays that supports most of the AbstractArray interface.  The constructor allocates a KnetArray in the currently active device, as specified by <code>gpu()</code>.  KnetArrays and Arrays can be converted to each other as shown above, which involves copying to and from the GPU memory.  Only Float32/64 KnetArrays are fully supported.</p><p>Important differences from the alternative CudaArray are: (1) a custom memory manager that minimizes the number of calls to the slow cudaMalloc by reusing already allocated but garbage collected GPU pointers.  (2) a custom getindex that handles ranges such as <code>a[5:10]</code> as views with shared memory instead of copies.  (3) custom CUDA kernels that implement elementwise, broadcasting, and reduction operations.</p><p><strong>Supported functions:</strong></p><ul><li><p>Indexing: getindex, setindex! with the following index types:</p><ul><li>1-D: Real, Colon, OrdinalRange, AbstractArray{Real}, AbstractArray{Bool}, CartesianIndex, AbstractArray{CartesianIndex}, EmptyArray, KnetArray{Int32} (low level), KnetArray{0/1} (using float for BitArray) (1-D includes linear indexing of multidimensional arrays)</li><li>2-D: (Colon,Union{Real,Colon,OrdinalRange,AbstractVector{Real},AbstractVector{Bool},KnetVector{Int32}}), (Union{Real,AbstractUnitRange,Colon}...) (in any order)</li><li>N-D: (Real...)</li></ul></li><li><p>Array operations: ==, !=, cat, convert, copy, copyto!, deepcopy, display, eachindex, eltype, endof, fill!, first, hcat, isapprox, isempty, length, ndims, one, ones, pointer, rand!, randn!, reshape, similar, size, stride, strides, summary, vcat, vec, zero. (cat(x,y,dims=i) supported for i=1,2.)</p></li><li><p>Math operators: (-), abs, abs2, acos, acosh, asin, asinh, atan, atanh, cbrt, ceil, cos, cosh, cospi, erf, erfc, erfcinv, erfcx, erfinv, exp, exp10, exp2, expm1, floor, log, log10, log1p, log2, round, sign, sin, sinh, sinpi, sqrt, tan, tanh, trunc</p></li><li><p>Broadcasting operators: (.*), (.+), (.-), (./), (.&lt;), (.&lt;=), (.!=), (.==), (.&gt;), (.&gt;=), (.^), max, min.  (Boolean operators generate outputs with same type as inputs; no support for KnetArray{Bool}.)</p></li><li><p>Reduction operators: countnz, maximum, mean, minimum, prod, sum, sumabs, sumabs2, norm.</p></li><li><p>Linear algebra: (*), axpy!, permutedims (up to 5D), transpose</p></li><li><p>Knet extras: relu, sigm, invx, logp, logsumexp, conv4, pool, deconv4, unpool, mat, update! (Only 4D/5D, Float32/64 KnetArrays support conv4, pool, deconv4, unpool)</p></li></ul><p><strong>Memory management</strong></p><p>Knet models do not overwrite arrays which need to be preserved for gradient calculation.  This leads to a lot of allocation and regular GPU memory allocation is prohibitively slow. Fortunately most models use identically sized arrays over and over again, so we can minimize the number of actual allocations by reusing preallocated but garbage collected pointers.</p><p>When Julia gc reclaims a KnetArray, a special finalizer keeps its pointer in a table instead of releasing the memory.  If an array with the same size in bytes is later requested, the same pointer is reused. The exact algorithm for allocation is:</p><ol><li><p>Try to find a previously allocated and garbage collected pointer in the current device. (0.5 μs)</p></li><li><p>If not available, try to allocate a new array using cudaMalloc. (10 μs)</p></li><li><p>If not successful, try running gc() and see if we get a pointer of the right size. (75 ms, but this should be amortized over all reusable pointers that become available due to the gc)</p></li><li><p>Finally if all else fails, clean up all saved pointers in the current device using cudaFree and try allocation one last time. (25-70 ms, however this causes the elimination of all reusable pointers)</p></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/karray.jl#L1-L81">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.accuracy" href="#Knet.accuracy"><code>Knet.accuracy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">accuracy(scores, answers; dims=1, average=true)</code></pre><p>Given an unnormalized <code>scores</code> matrix and an <code>Integer</code> array of correct <code>answers</code>, return the ratio of instances where the correct answer has the maximum score. <code>dims=1</code> means instances are in columns, <code>dims=2</code> means instances are in rows. Use <code>average=false</code> to return the number of correct answers instead of the ratio.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L249-L259">source</a><div><div><pre><code class="language-none">accuracy(model, data; dims=1, average=true, o...)</code></pre><p>Compute <code>accuracy(model(x; o...), y; dims)</code> for <code>(x,y)</code> in <code>data</code> and return the ratio (if average=true) or the count (if average=false) of correct answers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L310-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.dir" href="#Knet.dir"><code>Knet.dir</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Knet.dir(path...)</code></pre><p>Construct a path relative to Knet root.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; Knet.dir(&quot;examples&quot;,&quot;mnist.jl&quot;)
&quot;/home/dyuret/.julia/v0.5/Knet/examples/mnist.jl&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/Knet.jl#L40-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.dropout" href="#Knet.dropout"><code>Knet.dropout</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dropout(x, p)</code></pre><p>Given an array <code>x</code> and probability <code>0&lt;=p&lt;=1</code>, just return <code>x</code> if <code>p==0</code>, or return an array <code>y</code> in which each element is 0 with probability <code>p</code> or <code>x[i]/(1-p)</code> with probability <code>1-p</code>.  Use <code>seed::Number</code> to set the random number seed for reproducible results. See <a href="http://www.jmlr.org/papers/v15/srivastava14a.html">(Srivastava et al. 2014)</a> for a reference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/dropout.jl#L8-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.gpu" href="#Knet.gpu"><code>Knet.gpu</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>gpu()</code> returns the id of the active GPU device or -1 if none are active.</p><p><code>gpu(true)</code> resets all GPU devices and activates the one with the most available memory.</p><p><code>gpu(false)</code> resets and deactivates all GPU devices.</p><p><code>gpu(d::Int)</code> activates the GPU device <code>d</code> if <code>0 &lt;= d &lt; gpuCount()</code>, otherwise deactivates devices.</p><p><code>gpu(true/false)</code> resets all devices.  If there are any allocated KnetArrays their pointers will be left dangling.  Thus <code>gpu(true/false)</code> should only be used during startup.  If you want to suspend GPU use temporarily, use <code>gpu(-1)</code>.</p><p><code>gpu(d::Int)</code> does not reset the devices.  You can select a previous device and find allocated memory preserved.  However trying to operate on arrays of an inactive device will result in error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/gpu.jl#L44-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.invx" href="#Knet.invx"><code>Knet.invx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>invx(x) = (1./x)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/unary.jl#L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.gc" href="#Knet.gc"><code>Knet.gc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Knet.gc(dev=gpu())</code></pre><p>cudaFree all pointers allocated on device <code>dev</code> that were previously allocated and garbage collected. Normally Knet holds on to all garbage collected pointers for reuse. Try this if you run out of GPU memory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/kptr.jl#L151-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.softmax" href="#Knet.softmax"><code>Knet.softmax</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">softmax(x; dims=1, algo=1)</code></pre><p>The softmax function typically used in classification. Gives the same results as to <code>exp.(logp(x, dims))</code>. </p><p>If <code>algo=1</code> computation is more accurate, if <code>algo=0</code> it is  faster. </p><p>See also <code>logsoftmax</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L90-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.logp" href="#Knet.logp"><code>Knet.logp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logp(x; dims=:)</code></pre><p>Treat entries in <code>x</code> as as unnormalized log probabilities and return normalized log probabilities.</p><p><code>dims</code> is an optional argument, if not specified the normalization is over the whole <code>x</code>, otherwise the normalization is performed over the given dimensions.  In particular, if <code>x</code> is a matrix, <code>dims=1</code> normalizes columns of <code>x</code> and <code>dims=2</code> normalizes rows of <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L1-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.logsoftmax" href="#Knet.logsoftmax"><code>Knet.logsoftmax</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> logsoftmax(x; dims=:)</code></pre><p>Equivalent to <code>logp(x; dims=:)</code>. See also <code>sotfmax</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L122-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.logsumexp" href="#Knet.logsumexp"><code>Knet.logsumexp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logsumexp(x;dims=:)</code></pre><p>Compute <code>log(sum(exp(x);dims))</code> in a numerically stable manner.</p><p><code>dims</code> is an optional argument, if not specified the summation is over the whole <code>x</code>, otherwise the summation is performed over the given dimensions.  In particular if <code>x</code> is a matrix, <code>dims=1</code> sums columns of <code>x</code> and <code>dims=2</code> sums rows of <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L186-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.logistic" href="#Knet.logistic"><code>Knet.logistic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logistic(scores, answers; average=true)</code></pre><p>Computes logistic loss given scores(predicted values) and answer labels. answer values should be {-1,1}, then it returns <code>mean|sum(log(1 + exp(-answers*scores)))</code>. See also <code>bce</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L223-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.bce" href="#Knet.bce"><code>Knet.bce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bce(scores,answers;average=true)</code></pre><p>Computes binary cross entropy given scores(predicted values) and answer labels. answer values should be {0,1}, then it returns negative of <code>mean|sum(answers * log(p) + (1-answers)*log(1-p))</code> where <code>p</code> is equal to <code>1/(1 + exp.(scores))</code>. See also <code>logistic</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L234-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.minibatch" href="#Knet.minibatch"><code>Knet.minibatch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">minibatch(x, [y], batchsize; shuffle, partial, xtype, ytype, xsize, ysize)</code></pre><p>Return an iterable of minibatches [(xi,yi)...] given data tensors x, y and batchsize.  The last dimension of x and y should match and give the number of instances. <code>y</code> is optional.  Keyword arguments:</p><ul><li><code>shuffle=false</code>: Shuffle the instances before minibatching.</li><li><code>partial=false</code>: If true include the last partial minibatch &lt; batchsize.</li><li><code>xtype=typeof(x)</code>: Convert xi in minibatches to this type.</li><li><code>ytype=typeof(y)</code>: Convert yi in minibatches to this type.</li><li><code>xsize=size(x)</code>: Convert xi in minibatches to this shape.</li><li><code>ysize=size(y)</code>: Convert yi in minibatches to this shape.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/data.jl#L6-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.nll" href="#Knet.nll"><code>Knet.nll</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nll(scores, answers; dims=1, average=true)</code></pre><p>Given an unnormalized <code>scores</code> matrix and an <code>Integer</code> array of correct <code>answers</code>, return the per-instance negative log likelihood. <code>dims=1</code> means instances are in columns, <code>dims=2</code> means instances are in rows.  Use <code>average=false</code> to return the sum instead of per-instance average.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L206-L216">source</a><div><div><pre><code class="language-none">nll(model, data; dims=1, average=true, o...)</code></pre><p>Compute <code>nll(model(x; o...), y; dims)</code> for <code>(x,y)</code> in <code>data</code> and return the per-instance average (if average=true) or total (if average=false) negative log likelihood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/loss.jl#L294-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.relu" href="#Knet.relu"><code>Knet.relu</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">relu(x)</code></pre><p>Return <code>max(0,x)</code>.</p><p>Reference: Rectified Linear Units Improve Restricted Boltzmann Machines (https://icml.cc/Conferences/2010/abstracts.html#432).</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/unary.jl#L70-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.seed!" href="#Knet.seed!"><code>Knet.seed!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Knet.seed!(n::Integer)</code></pre><p>Run seed!(n) on both cpu and gpu.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/random.jl#L33-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.sigm" href="#Knet.sigm"><code>Knet.sigm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sigm(x) = (1./(1+exp(-x)))</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/unary.jl#L68">source</a></section><h2><a class="nav-anchor" id="Convolution-and-Pooling-1" href="#Convolution-and-Pooling-1">Convolution and Pooling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.conv4" href="#Knet.conv4"><code>Knet.conv4</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">conv4(w, x; kwargs...)</code></pre><p>Execute convolutions or cross-correlations using filters specified with <code>w</code> over tensor <code>x</code>.</p><p>Currently KnetArray{Float32/64,4/5} and Array{Float32/64,4} are supported as <code>w</code> and <code>x</code>.  If <code>w</code> has dimensions <code>(W1,W2,...,I,O)</code> and <code>x</code> has dimensions <code>(X1,X2,...,I,N)</code>, the result <code>y</code> will have dimensions <code>(Y1,Y2,...,O,N)</code> where</p><pre><code class="language-none">Yi=1+floor((Xi+2*padding[i]-Wi)/stride[i])</code></pre><p>Here <code>I</code> is the number of input channels, <code>O</code> is the number of output channels, <code>N</code> is the number of instances, and <code>Wi,Xi,Yi</code> are spatial dimensions.  <code>padding</code> and <code>stride</code> are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.</p><p><strong>Keywords</strong></p><ul><li><code>padding=0</code>: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.</li><li><code>stride=1</code>: the number of elements to slide to reach the next filtering window.</li><li><code>upscale=1</code>: upscale factor for each dimension.</li><li><code>mode=0</code>: 0 for convolution and 1 for cross-correlation.</li><li><code>alpha=1</code>: can be used to scale the result.</li><li><code>handle</code>: handle to a previously created cuDNN context. Defaults to a Knet allocated handle.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/conv.jl#L4-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.deconv4" href="#Knet.deconv4"><code>Knet.deconv4</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">y = deconv4(w, x; kwargs...)</code></pre><p>Simulate 4-D deconvolution by using <em>transposed convolution</em> operation. Its forward pass is equivalent to backward pass of a convolution (gradients with respect to input tensor). Likewise, its backward pass (gradients with respect to input tensor) is equivalent to forward pass of a convolution. Since it swaps forward and backward passes of convolution operation, padding and stride options belong to output tensor. See <a href="https://arxiv.org/abs/1603.07285">this report</a> for further explanation.</p><p>Currently KnetArray{Float32/64,4} and Array{Float32/64,4} are supported as <code>w</code> and <code>x</code>.  If <code>w</code> has dimensions <code>(W1,W2,...,O,I)</code> and <code>x</code> has dimensions <code>(X1,X2,...,I,N)</code>, the result <code>y</code> will have dimensions <code>(Y1,Y2,...,O,N)</code> where</p><p>Yi = Wi+stride[i]<em>(Xi-1)-2</em>padding[i]</p><p>Here I is the number of input channels, O is the number of output channels, N is the number of instances, and Wi,Xi,Yi are spatial dimensions. padding and stride are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.</p><p><strong>Keywords</strong></p><ul><li><code>padding=0</code>: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.</li><li><code>stride=1</code>: the number of elements to slide to reach the next filtering window.</li><li><code>mode=0</code>: 0 for convolution and 1 for cross-correlation.</li><li><code>alpha=1</code>: can be used to scale the result.</li><li><code>handle</code>: handle to a previously created cuDNN context. Defaults to a Knet allocated handle.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/conv.jl#L171-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.mat" href="#Knet.mat"><code>Knet.mat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mat(x)</code></pre><p>Reshape x into a two-dimensional matrix.</p><p>This is typically used when turning the output of a 4-D convolution result into a 2-D input for a fully connected layer.  For 1-D inputs returns <code>reshape(x, (length(x),1))</code>.  For inputs with more than two dimensions of size <code>(X1,X2,...,XD)</code>, returns</p><pre><code class="language-none">reshape(x, (X1*X2*...*X[D-1],XD))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/linalg.jl#L140-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.pool" href="#Knet.pool"><code>Knet.pool</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pool(x; kwargs...)</code></pre><p>Compute pooling of input values (i.e., the maximum or average of several adjacent values) to produce an output with smaller height and/or width.</p><p>Currently 4 or 5 dimensional KnetArrays with <code>Float32</code> or <code>Float64</code> entries are supported.  If <code>x</code> has dimensions <code>(X1,X2,...,I,N)</code>, the result <code>y</code> will have dimensions <code>(Y1,Y2,...,I,N)</code> where</p><pre><code class="language-none">Yi=1+floor((Xi+2*padding[i]-window[i])/stride[i])</code></pre><p>Here <code>I</code> is the number of input channels, <code>N</code> is the number of instances, and <code>Xi,Yi</code> are spatial dimensions.  <code>window</code>, <code>padding</code> and <code>stride</code> are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.</p><p><strong>Keywords:</strong></p><ul><li><code>window=2</code>: the pooling window size for each dimension.</li><li><code>padding=0</code>: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.</li><li><code>stride=window</code>: the number of elements to slide to reach the next pooling window.</li><li><code>mode=0</code>: 0 for max, 1 for average including padded values, 2 for average excluding padded values.</li><li><code>maxpoolingNanOpt=0</code>: Nan numbers are not propagated if 0, they are propagated if 1.</li><li><code>alpha=1</code>: can be used to scale the result.</li><li><code>handle</code>: Handle to a previously created cuDNN context. Defaults to a Knet allocated handle.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/conv.jl#L94-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.unpool" href="#Knet.unpool"><code>Knet.unpool</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Unpooling; <code>reverse</code> of pooling.</p><pre><code class="language-none">x == pool(unpool(x;o...); o...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/conv.jl#L149-L155">source</a></section><h2><a class="nav-anchor" id="Recurrent-neural-networks-1" href="#Recurrent-neural-networks-1">Recurrent neural networks</a></h2><pre><code class="language-none">Knet.rnninit
Knet.rnnforw
Knet.rnnparam
Knet.rnnparams</code></pre><h2><a class="nav-anchor" id="Batch-Normalization-1" href="#Batch-Normalization-1">Batch Normalization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.bnmoments" href="#Knet.bnmoments"><code>Knet.bnmoments</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>bnmoments(;momentum=0.1, mean=nothing, var=nothing, meaninit=zeros, varinit=ones)</code> can be used  directly load moments from data. <code>meaninit</code> and <code>varinit</code> are called if <code>mean</code> and <code>var</code> are nothing. Type and size of the <code>mean</code> and <code>var</code> are determined automatically from the inputs in the <code>batchnorm</code> calls. A <code>BNMoments</code> object is returned.</p><p><strong>BNMoments</strong></p><p>A high-level data structure used to store running mean and running variance of batch normalization with the following fields:</p><p><code>momentum::AbstractFloat</code>: A real number between 0 and 1 to be used as the scale of   last mean and variance. The existing running mean or variance is multiplied by   (1-momentum).</p><p><code>mean</code>: The running mean.</p><p><code>var</code>: The running variance.</p><p><code>meaninit</code>: The function used for initialize the running mean. Should either be <code>nothing</code> or of the form <code>(eltype, dims...)-&gt;data</code>. <code>zeros</code> is a good option.</p><p><code>varinit</code>: The function used for initialize the running variance. Should either be <code>nothing</code> or <code>(eltype, dims...)-&gt;data</code>. <code>ones</code> is a good option.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/batchnorm.jl#L3-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.bnparams" href="#Knet.bnparams"><code>Knet.bnparams</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>bnparams(etype, channels)</code> creates a single 1d array that contains both scale and bias of batchnorm, where the first half is scale and the second half is bias.</p><p><code>bnparams(channels)</code> calls <code>bnparams</code> with <code>etype=Float64</code>, following Julia convention</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/batchnorm.jl#L105-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.batchnorm" href="#Knet.batchnorm"><code>Knet.batchnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>batchnorm(x[, moments, params]; kwargs...)</code> performs batch normalization to <code>x</code> with optional scaling factor and bias stored in <code>params</code>.</p><p>2d, 4d and 5d inputs are supported. Mean and variance are computed over dimensions (2,), (1,2,4) and (1,2,3,5) for 2d, 4d and 5d arrays, respectively.</p><p><code>moments</code> stores running mean and variance to be used in testing. It is optional in the training mode, but mandatory in the test mode. Training and test modes are controlled by the <code>training</code> keyword argument.</p><p><code>params</code> stores the optional affine parameters gamma and beta. <code>bnparams</code> function can be used to initialize <code>params</code>.</p><p><strong>Example</strong></p><pre><code class="language-none"># Inilization, C is an integer
moments = bnmoments()
params = bnparams(C)
...
# size(x) -&gt; (H, W, C, N)
y = batchnorm(x, moments, params)
# size(y) -&gt; (H, W, C, N)</code></pre><p><strong>Keywords</strong></p><p><code>eps=1e-5</code>: The epsilon parameter added to the variance to avoid division by 0.</p><p><code>training</code>: When <code>training</code> is true, the mean and variance of <code>x</code> are used and <code>moments</code>  argument is modified if it is provided. When <code>training</code> is false, mean and variance stored in  the <code>moments</code> argument are used. Default value is <code>true</code> when at least one of <code>x</code> and <code>params</code>  is <code>AutoGrad.Value</code>, <code>false</code> otherwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/batchnorm.jl#L41-L76">source</a></section><h2><a class="nav-anchor" id="Optimization-methods-1" href="#Optimization-methods-1">Optimization methods</a></h2><pre><code class="language-none">Knet.update!
Knet.optimizers
Knet.Adadelta
Knet.Adagrad
Knet.Adam
Knet.Momentum
Knet.Nesterov
Knet.Rmsprop
Knet.Sgd</code></pre><h2><a class="nav-anchor" id="Hyperparameter-optimization-1" href="#Hyperparameter-optimization-1">Hyperparameter optimization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.goldensection" href="#Knet.goldensection"><code>Knet.goldensection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">goldensection(f,n;kwargs) =&gt; (fmin,xmin)</code></pre><p>Find the minimum of <code>f</code> using concurrent golden section search in <code>n</code> dimensions. See <code>Knet.goldensection_demo()</code> for an example.</p><p><code>f</code> is a function from a <code>Vector{Float64}</code> of length <code>n</code> to a <code>Number</code>.  It can return <code>NaN</code> for out of range inputs.  Goldensection will always start with a zero vector as the initial input to <code>f</code>, and the initial step size will be 1 in each dimension.  The user should define <code>f</code> to scale and shift this input range into a vector meaningful for their application. For positive inputs like learning rate or hidden size, you can use a transformation such as <code>x0*exp(x)</code> where <code>x</code> is a value <code>goldensection</code> passes to <code>f</code> and <code>x0</code> is your initial guess for this value. This will effectively start the search at <code>x0</code>, then move with multiplicative steps.</p><p>I designed this algorithm combining ideas from <a href="http://apps.nrbook.com/empanel/index.html?pg=492">Golden Section Search</a> and <a href="https://en.wikipedia.org/wiki/Hill_climbing">Hill Climbing Search</a>. It essentially runs golden section search concurrently in each dimension, picking the next step based on estimated gain.</p><p><strong>Keyword arguments</strong></p><ul><li><code>dxmin=0.1</code>: smallest step size.</li><li><code>accel=φ</code>: acceleration rate. Golden ratio <code>φ=1.618...</code> is best.</li><li><code>verbose=false</code>: use <code>true</code> to print individual steps.</li><li><code>history=[]</code>: cache of <code>[(x,f(x)),...]</code> function evaluations.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/hyperopt.jl#L1-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.hyperband" href="#Knet.hyperband"><code>Knet.hyperband</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hyperband(getconfig, getloss, maxresource=27, reduction=3)</code></pre><p>Hyperparameter optimization using the hyperband algorithm from (<a href="https://arxiv.org/abs/1603.06560">Lisha et al. 2016</a>).  You can try a simple MNIST example using <code>Knet.hyperband_demo()</code>. </p><p><strong>Arguments</strong></p><ul><li><code>getconfig()</code> returns random configurations with a user defined type and distribution.</li><li><code>getloss(c,n)</code> returns loss for configuration <code>c</code> and number of resources (e.g. epochs) <code>n</code>.</li><li><code>maxresource</code> is the maximum number of resources any one configuration should be given.</li><li><code>reduction</code> is an algorithm parameter (see paper), 3 is a good value.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/hyperopt.jl#L109-L123">source</a></section><h2><a class="nav-anchor" id="Initialization-1" href="#Initialization-1">Initialization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.bilinear" href="#Knet.bilinear"><code>Knet.bilinear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Bilinear interpolation filter weights; used for initializing deconvolution layers.</p><p>Adapted from https://github.com/shelhamer/fcn.berkeleyvision.org/blob/master/surgery.py#L33</p><p>Arguments:</p><p><code>T</code> : Data Type</p><p><code>fw</code>: Width upscale factor</p><p><code>fh</code>: Height upscale factor</p><p><code>IN</code>: Number of input filters</p><p><code>ON</code>: Number of output filters</p><p>Example usage:</p><p>w = bilinear(Float32,2,2,128,128)</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/distributions.jl#L44-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.gaussian" href="#Knet.gaussian"><code>Knet.gaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gaussian(a...; mean=0.0, std=0.01)</code></pre><p>Return a Gaussian array with a given mean and standard deviation.  The <code>a</code> arguments are passed to <code>randn</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/distributions.jl#L1-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.xavier" href="#Knet.xavier"><code>Knet.xavier</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xavier(a...)</code></pre><p>Xavier initialization.  The <code>a</code> arguments are passed to <code>rand</code>.  See (<a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">Glorot and Bengio 2010</a>) for a description. <a href="http://caffe.berkeleyvision.org/doxygen/classcaffe_1_1XavierFiller.html#details">Caffe</a> implements this slightly differently. <a href="http://lasagne.readthedocs.org/en/latest/modules/init.html#lasagne.init.GlorotUniform">Lasagne</a> calls it <code>GlorotUniform</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/eed9f58a3694f1d32f2b1e0c8c71f183d5c516a5/src/distributions.jl#L15-L27">source</a></section><h2><a class="nav-anchor" id="AutoGrad-(advanced)-1" href="#AutoGrad-(advanced)-1">AutoGrad (advanced)</a></h2><pre><code class="language-none">AutoGrad.getval
AutoGrad.@primitive
AutoGrad.@zerograd</code></pre><h2><a class="nav-anchor" id="Function-Index-1" href="#Function-Index-1">Function Index</a></h2><ul><li><a href="reference.html#Knet.Adadelta"><code>Knet.Adadelta</code></a></li><li><a href="reference.html#Knet.Adagrad"><code>Knet.Adagrad</code></a></li><li><a href="reference.html#Knet.Adam"><code>Knet.Adam</code></a></li><li><a href="reference.html#Knet.KnetArray"><code>Knet.KnetArray</code></a></li><li><a href="reference.html#Knet.Momentum"><code>Knet.Momentum</code></a></li><li><a href="reference.html#Knet.Nesterov"><code>Knet.Nesterov</code></a></li><li><a href="reference.html#Knet.Rmsprop"><code>Knet.Rmsprop</code></a></li><li><a href="reference.html#AutoGrad.grad"><code>AutoGrad.grad</code></a></li><li><a href="reference.html#AutoGrad.gradcheck"><code>AutoGrad.gradcheck</code></a></li><li><a href="reference.html#AutoGrad.gradloss"><code>AutoGrad.gradloss</code></a></li><li><a href="reference.html#Knet.accuracy"><code>Knet.accuracy</code></a></li><li><a href="reference.html#Knet.batchnorm"><code>Knet.batchnorm</code></a></li><li><a href="reference.html#Knet.bce"><code>Knet.bce</code></a></li><li><a href="reference.html#Knet.bilinear"><code>Knet.bilinear</code></a></li><li><a href="reference.html#Knet.bnmoments"><code>Knet.bnmoments</code></a></li><li><a href="reference.html#Knet.bnparams"><code>Knet.bnparams</code></a></li><li><a href="reference.html#Knet.conv4"><code>Knet.conv4</code></a></li><li><a href="reference.html#Knet.deconv4"><code>Knet.deconv4</code></a></li><li><a href="reference.html#Knet.dir"><code>Knet.dir</code></a></li><li><a href="reference.html#Knet.dropout"><code>Knet.dropout</code></a></li><li><a href="reference.html#Knet.gaussian"><code>Knet.gaussian</code></a></li><li><a href="reference.html#Knet.gc"><code>Knet.gc</code></a></li><li><a href="reference.html#Knet.goldensection"><code>Knet.goldensection</code></a></li><li><a href="reference.html#Knet.gpu"><code>Knet.gpu</code></a></li><li><a href="reference.html#Knet.hyperband"><code>Knet.hyperband</code></a></li><li><a href="reference.html#Knet.invx"><code>Knet.invx</code></a></li><li><a href="reference.html#Knet.logistic"><code>Knet.logistic</code></a></li><li><a href="reference.html#Knet.logp"><code>Knet.logp</code></a></li><li><a href="reference.html#Knet.logsoftmax"><code>Knet.logsoftmax</code></a></li><li><a href="reference.html#Knet.logsumexp"><code>Knet.logsumexp</code></a></li><li><a href="reference.html#Knet.mat"><code>Knet.mat</code></a></li><li><a href="reference.html#Knet.minibatch"><code>Knet.minibatch</code></a></li><li><a href="reference.html#Knet.nll"><code>Knet.nll</code></a></li><li><a href="reference.html#Knet.optimizers"><code>Knet.optimizers</code></a></li><li><a href="reference.html#Knet.pool"><code>Knet.pool</code></a></li><li><a href="reference.html#Knet.relu"><code>Knet.relu</code></a></li><li><a href="reference.html#Knet.rnnparam"><code>Knet.rnnparam</code></a></li><li><a href="reference.html#Knet.rnnparams"><code>Knet.rnnparams</code></a></li><li><a href="reference.html#Knet.seed!"><code>Knet.seed!</code></a></li><li><a href="reference.html#Knet.sigm"><code>Knet.sigm</code></a></li><li><a href="reference.html#Knet.softmax"><code>Knet.softmax</code></a></li><li><a href="reference.html#Knet.unpool"><code>Knet.unpool</code></a></li><li><a href="reference.html#Knet.update!"><code>Knet.update!</code></a></li><li><a href="reference.html#Knet.xavier"><code>Knet.xavier</code></a></li><li><a href="reference.html#AutoGrad.@primitive"><code>AutoGrad.@primitive</code></a></li><li><a href="reference.html#AutoGrad.@zerograd"><code>AutoGrad.@zerograd</code></a></li></ul><footer><hr/><a class="previous" href="tutorial.html"><span class="direction">Previous</span><span class="title">Introduction to Knet</span></a><a class="next" href="backprop.html"><span class="direction">Next</span><span class="title">Backpropagation</span></a></footer></article></body></html>
